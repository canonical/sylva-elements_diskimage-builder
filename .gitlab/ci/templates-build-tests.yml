---

.default-build:
  tags:
    - saas-linux-medium-amd64
  image: $UBUNTU_CI_IMAGE

.variables-definition:
    - export K8S_VERSION_SHORT=${K8S_VERSION%+*}
    - export DISK_IMAGE_NAME=${DISK_IMAGE_NAME//./-}-${K8S_VERSION_SHORT//./-}
    - export DISK_IMAGE_FILENAME=$DISK_IMAGE_NAME.$IMAGE_FORMAT
    - export REPO_IMAGE=$REPO_URL/$DISK_IMAGE_NAME:$OCI_TAG_FORMAT
    - export REPO_IMAGE_SNAPSHOT=$REPO_URL/snapshots/$DISK_IMAGE_NAME:$OCI_TAG_FORMAT

.build-image:
  extends: .default-build
  stage: build
  before_script:
    - python3 -m pip install --user . --break-system-packages
    - export PATH="${HOME}/.local/bin:/usr/local/bin:${PATH}"
  script:
    - !reference [ .variables-definition]
    - export HARDENED=$([[ "$FLAVOR" == "hardened" ]] && echo "true" || echo "false")
    - mkdir -p artifacts
    - kanod-image-builder -s target=$OS -s release=$OS_RELEASE $KANOD_OPTIONS --format $IMAGE_FORMAT -o $DISK_IMAGE_FILENAME
    - export sha256=$(sha256sum $DISK_IMAGE_FILENAME | awk '{ print $1 }')
    - export md5=$(md5sum $DISK_IMAGE_FILENAME | awk '{ print $1 }')
    - export size=$(ls -ls $DISK_IMAGE_FILENAME |  awk '{ print $6 }')
    - |
      echo "md5: $md5" | tee artifacts/checksum.md5
      echo "sha256: $sha256" | tee artifacts/checksum.sha256
    - |
      echo "Image format: $IMAGE_FORMAT"
      if [ $IMAGE_FORMAT = raw ]; then
        echo "Producing a raw image"
        export ARTIFACT_DISK_IMAGE_FILENAME=$DISK_IMAGE_FILENAME.gz
        export COMPRESSION=gz
        echo "$(date -Iseconds): Compressing to $ARTIFACT_DISK_IMAGE_FILENAME"
        gzip --fast $DISK_IMAGE_FILENAME
        echo "$(date -Iseconds): Done."
        export archive_size=$(ls -ls $ARTIFACT_DISK_IMAGE_FILENAME | awk '{ print $6 }')
      else
        echo "Producing a QCOW2 image"
        export ARTIFACT_DISK_IMAGE_FILENAME=$DISK_IMAGE_FILENAME
        export COMPRESSION=none
        export archive_size=0
      fi
    - digest_url=$(
        GODEBUG=http2client=0 flux push artifact
          oci://${REPO_IMAGE_SNAPSHOT}
          --timeout 2h --path="$ARTIFACT_DISK_IMAGE_FILENAME"
          --source="${CI_REPOSITORY_URL/gitlab-ci-token*@/}"
          --revision="$(git tag --points-at HEAD)@sha1:$(git rev-parse HEAD)"
          --creds $CI_REGISTRY_USER:$CI_REGISTRY_PASSWORD
          --annotations sylvaproject.org/diskimage/filename=$DISK_IMAGE_FILENAME
          --annotations sylvaproject.org/diskimage/os=$OS
          --annotations sylvaproject.org/diskimage/os-release=$OS_RELEASE
          --annotations sylvaproject.org/diskimage/flavor=$FLAVOR
          --annotations sylvaproject.org/diskimage/hardened=$HARDENED
          --annotations sylvaproject.org/diskimage/k8s-flavor=$K8S_FLAVOR
          --annotations sylvaproject.org/diskimage/k8s-version=${K8S_VERSION}
          --annotations sylvaproject.org/diskimage/sha256=$sha256
          --annotations sylvaproject.org/diskimage/md5=$md5
          --annotations sylvaproject.org/diskimage/size=$size
          --annotations sylvaproject.org/diskimage/archive-size=$archive_size
          --annotations sylvaproject.org/diskimage/image-format=$IMAGE_FORMAT
          --annotations sylvaproject.org/diskimage/compression=$COMPRESSION
          --annotations sylvaproject.org/diskimage/commit-id=$CI_COMMIT_SHA
          --annotations sylvaproject.org/diskimage/commit-tag=$OCI_TAG_FORMAT
          --output json |
        jq -r '. | .repository + "@" + .digest')
    - |
      if [[ ${COSIGN_PRIVATE_KEY} ]]; then
        echo "-- Signing $DISK_IMAGE_NAME image"
        cosign login $CI_REGISTRY -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD
        cosign sign -y --tlog-upload=false --key env://COSIGN_PRIVATE_KEY $digest_url
      fi
    - echo $digest_url | tee artifacts/snapshot.digest_url
  artifacts:
    when: always
    expire_in: 6h
    paths:
      - artifacts/checksum.sha256
      - artifacts/checksum.md5
      - artifacts/snapshot.digest_url

.build-image-suse:
  extends: .build-image
  image: $SUSE_CI_IMAGE
  before_script:
    - python3 -m pip install --user . --ignore-requires-python
    - export PATH="${HOME}/.local/bin:/usr/local/bin:${PATH}"
    - zypper install -y xfsprogs

.boot-image:
  extends: .default-build
  stage: boot
  script:
    - !reference [ .variables-definition]
    - mkdir -p artifacts oci_tmp
    - flux pull artifact oci://${REPO_IMAGE_SNAPSHOT} --timeout 20m -o .
    - |
      if [ -f $DISK_IMAGE_FILENAME.gz ]; then
        echo "Uncompressing $DISK_IMAGE_FILENAME"
        gunzip $DISK_IMAGE_FILENAME.gz
      fi
    - export VM_SERIAL_FILE=artifacts/serial.log
    - ./tests/ci/validate-img.sh ./$DISK_IMAGE_FILENAME
  artifacts:
    when: always
    expire_in: 6h
    paths:
      - artifacts/serial.log

.generate-sbom:
  extends: .default-build
  image: $GENERATE_OS_SBOM_CI_IMAGE
  stage: scan-image
  script:
    - !reference [ .variables-definition]
    - mkdir -p mountpoint artifacts
    - flux pull artifact oci://${REPO_IMAGE_SNAPSHOT} --timeout 20m -o .
    - |
      if [ -f $DISK_IMAGE_FILENAME.gz ]; then
        echo "Uncompressing $DISK_IMAGE_FILENAME"
        gunzip $DISK_IMAGE_FILENAME.gz
      fi
    - guestmount -a $DISK_IMAGE_FILENAME -i mountpoint
    - trivy rootfs --skip-db-update --java-db-repository registry.gitlab.com/gitlab-org/security-products/dependencies/trivy-java-db mountpoint -f cyclonedx -o artifacts/${DISK_IMAGE_FILENAME}.cdx
  cache:
    key: trivy
    paths:
      - .cache/trivy/
  artifacts:
    name: "${DISK_IMAGE_NAME}.cdx"
    paths:
      - artifacts/*.cdx
    reports:
      cyclonedx:
        - artifacts/*.cdx

.openscap-scan:
  extends: .default-build
  image: $OPENSCAP_CI_IMAGE
  stage: scan-image
  script:
    - !reference [ .variables-definition]
    - export OSCAP_DEFINITION_FILE="/usr/share/xml/scap/ssg/content/ssg-${SSG_FILE_LABEL}-ds.xml"
    - flux pull artifact oci://${REPO_IMAGE_SNAPSHOT} --timeout 20m -o .
    - |
      if [ -f $DISK_IMAGE_FILENAME.gz ]; then
        echo "Uncompressing $DISK_IMAGE_FILENAME"
        gunzip $DISK_IMAGE_FILENAME.gz
      fi
    - |
      for profile in $SSG_PROFILE_LIST; do
        echo "Scanning $DISK_IMAGE_FILENAME with profile $profile";
        export REPORT_FILE_NAME=$DISK_IMAGE_NAME.openscap.$profile.html
        oscap-vm image $DISK_IMAGE_FILENAME xccdf eval --profile $profile --fetch-remote-resources --report $REPORT_FILE_NAME $OSCAP_DEFINITION_FILE >> output.log || true
      done
  artifacts:
    when: always
    paths:
      - "*.html"
      - output.log
  timeout: 2h

.openscap-scan-opensuse-oval:
  extends: .default-build
  image: $OPENSCAP_CI_IMAGE
  stage: scan-image
  script:
    - !reference [ .variables-definition]
    - curl -O $OVAL_URL
    - export OSCAP_DEFINITION_FILE=$(basename "$OVAL_URL")
    - flux pull artifact oci://${REPO_IMAGE_SNAPSHOT} --timeout 20m -o .
    - |
      if [ -f $DISK_IMAGE_FILENAME.gz ]; then
        echo "Uncompressing $DISK_IMAGE_FILENAME"
        gunzip $DISK_IMAGE_FILENAME.gz
      fi
    - echo "Scanning $DISK_IMAGE_FILENAME with $OVAL_URL";
    - export REPORT_FILE_NAME=$DISK_IMAGE_NAME.openscap.oval.html
    - oscap-vm image $DISK_IMAGE_FILENAME oval eval --report $REPORT_FILE_NAME $OSCAP_DEFINITION_FILE >> output.log || true
  artifacts:
    when: always
    paths:
      - "*.html"
      - output.log
  timeout: 2h

.promote-image:
  extends: .default-build
  stage: promote
  script:
    - !reference [ .variables-definition]
    - export sha256=$(cat artifacts/checksum.sha256)
    - echo $sha256
    - skopeo copy
        --dest-creds $CI_REGISTRY_USER:$CI_REGISTRY_PASSWORD
        --digestfile digest
        docker://${REPO_IMAGE_SNAPSHOT}
        docker://${REPO_IMAGE}
    - digest_url=$REPO_URL/$DISK_IMAGE_NAME@$(cat digest)
    - echo ${digest_url}
    - |
      if [[ ${COSIGN_PRIVATE_KEY} ]]; then
        echo "Check if artifact $digest_url is signed with the correct key"
        if cosign verify --insecure-ignore-tlog=true --key env://COSIGN_PUBLIC_KEY $digest_url; then
          echo "Artifact $digest_url exists and is already signed with the correct key, skipping it"
        else
          echo "[ERROR] Artifact $digest_url exists and is not signed with the correct key"
          exit 1
        fi
      fi
    - echo "Image pushed at oci://${REPO_IMAGE}"
    - |
      echo "<br /><br /> Image: \"oci://$REPO_URL/$DISK_IMAGE_NAME:$(git tag --points-at HEAD)\"" >> ${CI_PIPELINE_ID}-release.md
      echo "<br /> \"${sha256}\"" >> ${CI_PIPELINE_ID}-release.md
    - cat ${CI_PIPELINE_ID}-release.md
  artifacts:
    paths:
      - ${CI_PIPELINE_ID}-release.md

.publish-scan:
  extends: .default-build
  stage: publish-report
  script:
    - !reference [ .variables-definition]
    - echo "<br /> OpenSCAP report:" >> ${CI_PIPELINE_ID}-release.md
    - |
      for REPORT_FILE_NAME in *.html; do
        echo "Uploading $REPORT_FILE_NAME";
        curl --fail-with-body --header "JOB-TOKEN: $CI_JOB_TOKEN" --upload-file $REPORT_FILE_NAME "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/openscap/$CI_COMMIT_TAG/$REPORT_FILE_NAME"
        echo "[$profile](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/openscap/$CI_COMMIT_TAG/$REPORT_FILE_NAME)" >> ${CI_PIPELINE_ID}-release.md
      done
  artifacts:
    paths:
      - ${CI_PIPELINE_ID}-release.md
  rules:
    - if: $CI_COMMIT_TAG
